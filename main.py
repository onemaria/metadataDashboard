from datetime import timedelta
from http.client import HTTPException
import httpx
from fastapi import FastAPI, Depends, APIRouter
from typing import Annotated, List
import uvicorn
from fastapi.security import OAuth2PasswordBearer, HTTPBasicCredentials, HTTPBasic
from sqlalchemy.orm import Session
from starlette.responses import RedirectResponse
import models
from clients import schemas
from clients.clients import initialize_keycloak_client
from clients.database import init_db, insert_journal, SessionLocal
from clients.redis_client import set_key, get_key, delete_key, get_from_redis, cache_in_redis

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

app = FastAPI(title="UI for integrating Redis, PostgreSQL and Keycloak")

@app.get("/", include_in_schema = False)
async def docs_redirect():
    return RedirectResponse(url='/docs')



keycloak_router = APIRouter(prefix="/keycloak", tags=["Keycloak"])

# This endpoint is returning a token generated by the default Keycloak instance
@keycloak_router.post("/token",
             summary='Get an access token')
async def get_access_token(credentials: Annotated[HTTPBasicCredentials, Depends(HTTPBasic())]):
    keycloak_client = initialize_keycloak_client()
    try:
        token = keycloak_client.token(username=credentials.username, password=credentials.password)
        return token
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred: {e}")



redis_router = APIRouter(prefix="/redis", tags=["Redis DB"])
# This endpoint is adding key-value pairs in Redis DB
@redis_router.put('', summary='Register and update a new key-value pair')
def put_key_redis(key, value):
    set_key(key, value)

# This endpoint is getting the value of a key from Redis DB
@redis_router.get('/{key}', summary='Get the value of a given key')
def get_key_redis(key: str):
    return get_key(key)

# This endpoint is deleting a key-value pair from Redis DB giving a key
@redis_router.delete('/{key}', summary='Delete a key-value pair')
def delete_key_redis(key: str):
    delete_key(key)



postgres_router = APIRouter(prefix="/postgres", tags=["Postgres DB"])
# @app.on_event("startup")
# def startup():
#     init_db()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
@postgres_router.get("/journals/", response_model=List[schemas.CrossRefJournalResponse], summary="Get all journal data")
async def get_journals(db: Session = Depends(get_db)):
    journals = db.query(models.CrossRefJournal).all()
    return journals

@postgres_router.get("/journals/{journal_id}", response_model=schemas.CrossRefJournalResponse, summary="Get a specific journal by ID")
async def get_journal(journal_id: int, db: Session = Depends(get_db)):
    journal = db.query(models.CrossRefJournal).filter(models.CrossRefJournal.id == journal_id).first()
    if journal is None:
        raise HTTPException(status_code=404, detail="Journal not found")
    return journal





metadata_router = APIRouter(prefix="/metadata", tags=["CrossRef Metadata"])

@metadata_router.get("/fetch_crossref_journals")
async def fetch_crossref_journals(db: Session = Depends(get_db)):
    cache_key = "crossref_journals_health_cache"
    cached_data = get_from_redis(cache_key)
    if cached_data:
        return {"message": "Data retrieved from cache", "data": cached_data}

    url = "https://api.crossref.org/journals?query=health&mailto=maria%40test.com"
    async with httpx.AsyncClient() as client:
        response = await client.get(url, headers={"accept": "application/json"})

        if response.status_code == 200:
            data = response.json()

            cache_in_redis(cache_key, data, expiration=timedelta(days=1))

            for journal_item in data["message"]["items"]:
                insert_journal(db, journal_item)

            return {"message": "Data fetched, saved, and cached successfully", "data": data}
        else:
            raise HTTPException(status_code=500, detail="Failed to fetch data from CrossRef")

app.include_router(keycloak_router)
app.include_router(metadata_router)
app.include_router(redis_router)
app.include_router(postgres_router)

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
